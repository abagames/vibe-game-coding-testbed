---
description: 
globs: 
alwaysApply: true
---
# VGCT Architecture and Structure

## Overview
Vibe Game Coding Testbed (VGCT) is a framework for developing text-based games in a 40x25 character terminal environment. It supports both functional module and class-based architectures.

## Core Architecture

### Module Structure
- **Core Module** ([src/core/](mdc:src/core)): Base classes and type definitions
  - [BaseGame.ts](mdc:src/core/BaseGame.ts): Abstract base class for class-based games
  - [baseGame.ts](mdc:src/core/baseGame.ts): Functional module approach with pure functions
  - [coreTypes.ts](mdc:src/core/coreTypes.ts): Shared interfaces and constants
- **Utils Module** ([src/utils/](mdc:src/utils)): Common utilities
  - [browserHelper.ts](mdc:src/utils/browserHelper.ts): Browser integration helpers with dual support
  - [consoleSimulator.ts](mdc:src/utils/consoleSimulator.ts): Console-based testing utility
- **Games Module** ([src/games/](mdc:src/games)): Individual game implementations

### Architectural Approaches

#### 1. Functional Module Architecture (Recommended)
Uses pure functions and immutable state management:

```typescript
// State definition
export type GameState = BaseGameState & {
  playerX: number;
  playerY: number;
  // Game-specific state
};

// Core functions
export function createGame(options: GameOptions = {}): GameState;
export function initializeGame(state: GameState): GameState;
export function updateGame(state: GameState, input: InputState): GameState;
```

**Benefits:**
- Easier testing (pure functions)
- Better performance (immutable updates)
- Clearer data flow
- Simpler debugging

#### 2. GameManager Pattern (Advanced)
For complex games with multiple flow states:

```typescript
// Game flow state constants
const GAME_FLOW_STATE_TITLE = 0;
const GAME_FLOW_STATE_PLAYING = 1;
const GAME_FLOW_STATE_GAME_OVER = 2;

export type GameManagerState = GameState & {
  gameFlowState: number;
  titleAnimationTimer: number;
  gameOverTimer: number;
  isDemoMode: boolean;
};
```

**Use cases:**
- Games with title screens
- Demo mode support
- Complex state transitions
- Multi-phase gameplay

#### 3. Class-based Architecture (Legacy Support)
Traditional object-oriented approach:

```typescript
export class YourGame extends BaseGame {
  abstract initializeGame(): void;
  abstract updateGame(inputState: InputState): void;
}
```

**When to use:**
- Migrating existing code
- Strong OOP preference
- Complex inheritance needs

### Game Structure Patterns

#### Standard Functional Module Structure
```
src/games/[gameName]/
├── core.ts              // Pure game logic functions
├── sim.ts               // Basic simulation testing
├── browser.ts           // Browser entry point
└── index.html           // Browser execution HTML
```

#### GameManager Structure (Complex Games)
```
src/games/[gameName]/
├── core.ts              // Core game logic functions
├── gameManager.ts       // Flow state management
├── sim.ts               // Basic simulation testing
├── gameManagerSim.ts    // GameManager simulation testing
├── browser.ts           // Browser entry point
└── index.html           // Browser execution HTML
```

#### Class-based Structure (Legacy)
```
src/games/[gameName]/
├── core.ts              // Game class definition
├── sim.ts               // Simulation testing
├── browser.ts           // Browser entry point
└── index.html           // Browser execution HTML
```

### Browser Integration Patterns

#### Functional Module Integration
```typescript
// browser.ts
import { initStandardTextGame } from "../../utils/browserHelper.js";
import { createYourGame, initializeYourGame, updateYourGame } from "./core.js";

const gameFactory = (options: any = {}) => {
  const state = createYourGame(options);
  const operations = {
    initializeGame: initializeYourGame,
    updateGame: updateYourGame,
  };
  return { state, operations };
};

initStandardTextGame(gameFactory, {
  gameName: "Your Game",
  enableHighScoreStorage: true,
});
```

#### GameManager Integration
```typescript
// browser.ts for GameManager
import { createYourGameManager, updateGameManager } from "./gameManager.js";

const gameFactory = (options: any = {}) => {
  const state = createYourGameManager(options);
  const operations = {
    initializeGame: (state: any) => state, // GameManager handles its own init
    updateGame: updateGameManager,
  };
  return { state, operations };
};
```

#### Class-based Integration
```typescript
// browser.ts
import { initStandardTextGameForClass } from "../../utils/browserHelper.js";

initStandardTextGameForClass(
  () => new YourGame(),
  { gameName: "Your Game", enableHighScoreStorage: true }
);
```

### Key Constants and Specifications
- **Screen size**: 40 characters × 25 lines (VIRTUAL_SCREEN_WIDTH/HEIGHT)
- **Input mapping**: Standard keyboard (arrows, WASD, space, enter, Z/X)
- **Display**: ASCII characters only with color support
- **Frame rate**: Typically 60 FPS in browser, configurable in simulation
- **Color support**: Standard terminal colors via `CellAttributes`

### State Management Patterns

#### Immutable State Updates (Functional)
```typescript
// Always return new state objects
export function updateGame(state: GameState, input: InputState): GameState {
  return {
    ...state,
    playerX: newX,
    playerY: newY,
    score: state.score + points,
  };
}
```

#### Mutable State (Class-based)
```typescript
// Direct property modification
public updateGame(inputState: InputState): void {
  this.playerX = newX;
  this.playerY = newY;
  this.addScore(points);
}
```

### Testing Architecture

#### Functional Module Testing
```typescript
// Direct function testing
let gameState = createYourGame();
gameState = initializeYourGame(gameState);
gameState = updateYourGame(gameState, inputState);

// Easy to test state transformations
expect(gameState.playerX).toBe(expectedX);
```

#### GameManager Testing
```typescript
// Flow state testing
let managerState = createYourGameManager();
managerState = updateGameManager(managerState, { action1: true });
expect(managerState.gameFlowState).toBe(GAME_FLOW_STATE_PLAYING);
```

#### Class-based Testing
```typescript
// Traditional testing
const game = new YourGame();
game.initializeGame();
game.update(inputState);
expect(game.getScore()).toBe(expectedScore);
```

### Performance Characteristics

#### Functional Modules
- **Pros**: Immutable updates prevent side effects, easier to optimize
- **Cons**: Memory allocation for new state objects
- **Best for**: Games with complex state, frequent testing needs

#### GameManager
- **Pros**: Clear separation of concerns, easy flow management
- **Cons**: Additional complexity layer
- **Best for**: Games with multiple screens/phases

#### Class-based
- **Pros**: Familiar OOP patterns, direct state mutation
- **Cons**: Harder to test, potential side effects
- **Best for**: Simple games, legacy migration

### High Score and Persistence

#### Browser Environment
```typescript
// Automatic high score management
const gameFactory = (options: any = {}) => {
  return {
    state: createYourGame({
      ...options,
      isBrowserEnvironment: true,
      enableHighScoreStorage: true,
    }),
    operations: { /* ... */ }
  };
};
```

#### localStorage Integration
- High scores automatically saved/loaded
- Game name used as storage key
- Session high score tracking
- Browser-only feature (requires `isBrowserEnvironment: true`)

### Audio Integration

#### Functional Approach
```typescript
// Audio functions don't modify state
playSoundEffect(state, "powerUp", seed);
playBgm(state);
stopBgm(state);
```

#### Class-based Approach
```typescript
// Direct method calls
this.play("powerUp", seed);
this.playBgm();
this.stopBgm();
```

### Development Workflow

1. **Choose Architecture**: Start with functional modules for new projects
2. **Implement Core Logic**: Create state types and update functions
3. **Add GameManager** (if needed): For complex flow states
4. **Set Up Testing**: Create simulation files for rapid iteration
5. **Browser Integration**: Configure browser entry point
6. **Add NPM Scripts**: Set up build and test commands

### Migration Path

#### Class to Functional
1. Extract state to interfaces
2. Convert methods to pure functions
3. Update browser integration
4. Maintain parallel testing during transition

#### Functional to GameManager
1. Add flow state enum
2. Extend state with flow management
3. Create manager update function
4. Update browser integration

## Reference Implementation
See [defaultGame](mdc:src/games/defaultGame) for a complete example demonstrating:
- [Functional core logic](mdc:src/games/defaultGame/core.ts)
- [GameManager pattern](mdc:src/games/defaultGame/gameManager.ts)
- [Dual simulation setup](mdc:src/games/defaultGame/sim.ts) and [GameManager simulation](mdc:src/games/defaultGame/gameManagerSim.ts)
- [Browser integration](mdc:src/games/defaultGame/browser.ts)
- [Complete architecture](mdc:src/games/defaultGame) in action

---
description: Comprehensive strategies for proactive bug discovery in game development using simulation, parameter manipulation, and systematic testing. Use this rule when debugging game mechanics, investigating reported bugs, implementing new features that need testing, or when game behavior seems inconsistent or unexpected.
globs: 
alwaysApply: false
---
# Game Testing Strategies

## Proactive Bug Discovery Through Simulation

### Core Philosophy
Don't wait for bugs to surface naturally - actively hunt them down using controlled simulation environments and parameter manipulation.

### Simulation-Based Testing Pattern

#### 1. Create Dedicated Test Simulations
For each game in `src/games/[gameName]/`, create a `sim.ts` file. This file should:
- Import the game's core logic (e.g., `YourGameClass` from `./core.js`).
- Instantiate the game, often with modified parameters for specific test scenarios.
- Use controlled input sequences or input generation strategies.
- Provide detailed logging of internal state and a visual representation of the game state.

**Example Structure (Option A: Using a utility like `ConsoleSimulator` - Recommended for structured tests):**
```typescript
// src/games/[gameName]/sim.ts
import { YourGameClass, YourGameOptions } from "./core.js";
import { ConsoleSimulator } from "../../utils/consoleSimulator.js";
// import { NodeAudioService } from "../../utils/NodeAudioService.js"; // If audio testing is needed

const gameOptions: YourGameOptions = {
  // Modified parameters for testing
  initialLives: 1,
  // gameSpecificParameter: testValue,
  // audioService: new NodeAudioService(), // Example for audio
};

const game = new YourGameClass(gameOptions);

// Example: Predefined input sequence (ConsoleSimulator uses single char codes)
const predefinedMoves: string[] = "rrrr.a.dddd.a.llll".split(""); // . for no-op, a for action1

const simulator = new ConsoleSimulator(game, "predefined", {
  totalTicks: 100, // How many frames to simulate
  tickDurationMs: 50, // Speed of simulation (ms per tick)
  predefinedMoves: predefinedMoves,
});

game.initializeGame(); // Ensure game is initialized before simulation
simulator.run();
```
*The `ConsoleSimulator` (from `src/utils/consoleSimulator.ts`) provides modes like "predefined", "random", "fixed" input, and handles structured screen rendering and tick management.*

**Example Structure (Option B: Direct simulation loop - For simpler or highly custom tests):**
```typescript
// src/games/[gameName]/sim.ts
import { YourGameClass, YourGameOptions } from "./core.js";
import { InputState, VIRTUAL_SCREEN_WIDTH, VIRTUAL_SCREEN_HEIGHT } from "../../core/coreTypes.js";

function printGameScreen(game: YourGameClass) { /* ... see visualization section ... */ }

const gameOptions: YourGameOptions = { initialLives: 1 };
const game = new YourGameClass(gameOptions);
game.initializeGame();

let frame = 0;
const maxFrames = 200;

while(frame < maxFrames && !game.isGameOver()) {
  const input: InputState = { /* construct desired input for the frame */ };
  // Example: input.right = true; if (frame % 10 === 0) input.action1 = true;
  
  game.update(input);
  printGameScreen(game); // Visualize state
  console.log(`Frame: ${frame}, Score: ${game.getScore()}, Lives: ${game.getLives()}`);
  frame++;
}
console.log("Simulation ended.");
```

#### 2. Parameter Manipulation for Edge Cases
Temporarily modify game parameters to expose edge cases:

**Snake Length Manipulation:**
```typescript
// Test with unusually long snake
const initialSnakeLength = 20; // vs normal 10
(game as any).snake = createLongSnake(initialSnakeLength);
```

**Speed Manipulation:**
```typescript
// Test rapid movement for timing issues
movementInterval: 1, // vs normal 8
```

**Enemy System Manipulation:**
```typescript
// Disable enemies to isolate mechanics
enemySystem.updateSpawnSettings({
  minEnemyCount: 0,
  spawnInterval: 1000000,
});
```

#### 3. State Visualization and Logging
Add comprehensive logging to expose internal state. For screen visualization in the console, a helper function is useful:

```typescript
// Example printGameScreen function (adapt VIRTUAL_SCREEN_WIDTH/HEIGHT if needed)
import { VIRTUAL_SCREEN_WIDTH, VIRTUAL_SCREEN_HEIGHT } from "../../core/coreTypes.js"; // Or from your game's constants

function printGameScreen(game: YourGameClass): void { // YourGameClass should implement getVirtualScreenData()
  const screenData = game.getVirtualScreenData();
  let headerFooter = "+" + "-".repeat(VIRTUAL_SCREEN_WIDTH) + "+";
  console.log("\n" + headerFooter);
  for (let y = 0; y < VIRTUAL_SCREEN_HEIGHT; y++) {
    let row = "|";
    for (let x = 0; x < VIRTUAL_SCREEN_WIDTH; x++) {
      row += screenData[y][x]?.char || " "; // Access char safely
    }
    row += "|";
    console.log(row);
  }
  console.log(headerFooter);
  console.log(`Score: ${game.getScore()}, Lives: ${game.getLives()}, GameOver: ${game.isGameOver()}`);
  // Add any other relevant game-specific state here
}

// Internal state logging (remains as is)
// console.log(`Snake Head: (${head.x},${head.y}), Length: ${snake.length}`);
// console.log(`Guidelines: [${guidelines.map(g => `(${g.x},${g.y})`).join(" ")}]`);
```

### Specific Testing Strategies

#### Area Enclosure Testing
When testing area-based mechanics:
1. **Vary enclosure sizes**: Test tiny (3-5 cells) to large (50+ cells) areas
2. **Test boundary conditions**: Areas touching screen edges
3. **Test complex shapes**: L-shapes, spirals, nested areas
4. **Test guideline intersections**: Snake body crossing its own path

#### Collision Detection Testing
1. **Boundary testing**: Movement at screen edges
2. **Self-collision**: Snake hitting its own body at various angles
3. **Enemy collision**: Different enemy types and positions
4. **Multi-object collision**: Simultaneous collisions

#### Timing and Synchronization Testing
1. **Rapid input changes**: Direction changes every frame
2. **Frame-perfect scenarios**: Actions on exact frame boundaries
3. **State transition testing**: Game over, restart, pause scenarios

### Implementation Guidelines

#### Debug Logging Strategy
```typescript
// Use conditional logging for specific areas
if (x >= 10 && x <= 20 && y >= 10 && y <= 13) {
  console.log(`[DebugArea] Checking (${x},${y}). State: ${state}`);
}

// Use prefixed logging for different systems
console.log(`[AreaDetection] Found area: size=${size}`);
console.log(`[Explosion] Covering ${cellCount} cells`);
console.log(`[Movement] Snake head moved to (${x},${y})`);
```

#### Avoid Masking Real Issues with Manual Overrides

**DO NOT** use simulation to work around broken game logic. Manual positioning and forced spawning can hide actual implementation problems.

**Bad Practice Example:**
```typescript
// ❌ This masks the real issue that Guards don't spawn near food automatically
const guard1Id = guardManager.spawnGuard(
  { x: 20, y: 9 }, // Manually positioned near food
  { x: 20, y: 12 },
  true
);
```

**Good Practice Example:**
```typescript
// ✅ Test the actual game logic first
enemySystem.updateSpawnSettings({
  minEnemyCount: 3, // Enable automatic spawning
  spawnInterval: 120,
});

// Let the system spawn naturally, then verify behavior
// If Guards don't spawn near food, fix the spawn logic, don't override it
```

**Key Principles:**
1. **Test real behavior first**: Always verify the actual game logic before adding manual overrides
2. **Manual setup for specific scenarios only**: Use manual positioning only to test specific edge cases, not to work around broken systems
3. **Document when overriding**: Clearly comment why manual setup is necessary
4. **Fix root causes**: If manual setup is needed to make something work, there's likely a bug in the core logic

**Case Study: Guard Enemy Spawn Issue**
- **Problem**: Guards were spawning randomly instead of near food
- **Wrong approach**: Manually spawn Guards near food in simulation
- **Right approach**: Fix the `EnemySystemManager` to include food-aware spawn logic
- **Result**: Discovered and fixed the actual issue in `findValidSpawnPositionNearFood`

#### Temporary Code Modifications
When hunting specific bugs:
1. **Add boundary visualization**: Draw debug markers
2. **Slow down time**: Reduce movement intervals
3. **Add invincibility**: Skip collision detection temporarily
4. **Force specific states**: Set exact positions/conditions

#### NPM Script Integration
Add simulation scripts to [package.json](mdc:package.json):
```json
{
  "scripts": {
    "sim:gameName": "npx tsx src/games/gameName/sim.ts",
    "sim:debug": "npx tsx src/games/gameName/sim.ts --debug"
  }
}
```

### Bug Discovery Checklist

#### Before Implementing New Features
- [ ] Create simulation for the new mechanic
- [ ] Test with extreme parameters (very fast, very slow, very large, very small)
- [ ] Test boundary conditions
- [ ] Test interaction with existing systems

#### When Bug Reports Come In
- [ ] Reproduce in simulation first
- [ ] Isolate the specific conditions
- [ ] Add logging to suspected code paths
- [ ] Test variations of the scenario
- [ ] Verify fix doesn't break other scenarios

#### Regular Regression Testing
- [ ] Run existing simulations after code changes
- [ ] Test with different parameter combinations
- [ ] Verify visual output matches expectations
- [ ] Check performance with extreme scenarios

### Case Study: Blasnake Area Explosion Bug

**Problem**: Vertical area creation caused horizontal explosion spread

**Discovery Process**:
1. Created simulation with controlled snake movement
2. Used long snake (20 segments) to amplify the issue
3. Added detailed logging to area detection functions
4. Visualized screen state at key moments
5. Compared expected vs actual explosion boundaries

**Key Insight**: Boundary checking inconsistency between area detection and explosion filling

**Resolution**: Unified boundary logic across both systems

This demonstrates how proactive simulation testing can uncover subtle bugs that might otherwise go unnoticed in normal gameplay.

### Best Practices

1. **Start simple**: Begin with basic scenarios, then add complexity
2. **Document scenarios**: Comment what each test is trying to achieve
3. **Version control simulations**: Keep successful test cases for regression testing
4. **Share findings**: Document discovered edge cases for team knowledge
5. **Automate when possible**: Convert manual tests to automated checks

Remember: The goal is not just to find bugs, but to understand the system deeply enough to prevent similar issues in the future.



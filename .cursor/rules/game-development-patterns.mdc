---
description: 
globs: 
alwaysApply: true
---
# Game Development Patterns

## BaseGame Inheritance Pattern

### Required Implementation
All games must extend [BaseGame.ts](mdc:src/core/BaseGame.ts) and implement:
```typescript
abstract initializeGame(): void;
abstract updateGame(inputState: InputState): void;
```

### Constructor Pattern
Use named arguments with interfaces:
```typescript
interface YourGameOptions {
  initialLives?: number;
  gameSpeed?: number;
  // Add game-specific options
}

constructor(options: YourGameOptions = {}) {
  super(options); // Passes relevant options to BaseGame
  // Game-specific initialization
}
```

### Available BaseGame Methods
- `drawText(text, x, y, attributes?)`: Draw text to virtual screen.
- `drawCenteredText(text, y, attributes?)`: Draw centered text at y coordinate.
- `getCellInfo(x, y)`: Get cell information at coordinates.
- `addScore(value)`: Modify score. Updates session high score if current score is higher.
- `loseLife()`: Decrease lives. If lives reach 0, triggers game over.
- `gainLife(count?: number)`: Increase lives by `count` (default 1).
- `getScore()`: Get current score.
- `getLives()`: Get current number of lives.
- `isGameOver()`: Check if the game is over (returns boolean based on `gameOverState`).
- `triggerGameOver()`: Manually end the game (sets `gameOverState` to true) and commit high score.
- `getVirtualScreenData()`: Get the full grid data.
- `renderStandardUI()`: Draws score, lives, and restart instruction. Typically called by `BaseGame.update()`.
- `renderGameOverScreen()`: Draws the game over message, final score, high score, and restart prompt. Called by `BaseGame.update()` when `isGameOver()` is true. Note: Takes no arguments in `BaseGame.ts`.
- `setIsDemoPlay(isDemo: boolean)`: Set demo play mode (mutes audio by default).
- `play(sound: SoundEffectType, seed?: number)`: Play a sound effect (if not in demo mode and audioService is available).
- `playMml(mml: string | string[])`: Play MML music (if not in demo mode and audioService is available).
- `playBgm()`: Start background music (if not in demo mode and audioService is available).
- `stopBgm()`: Stop background music (if not in demo mode and audioService is available).
- `getHighScore()`: Get the current session's or stored high score.
- `commitHighScoreToStorage()`: Manually trigger saving the current high score (also done automatically on game over if enabled).
- `resetGame()` (protected): Resets score, lives to initial, `gameOverState` to false, and clears screen. Useful for restarting game logic, often called in the derived class's `initializeGame` or by a restart mechanism.

### BaseGame Constructor Options
```typescript
interface BaseGameOptions {
  initialLives?: number;    // Default: 3
  isDemoPlay?: boolean;     // Default: false. If true, audio might be disabled by game logic.
  audioService?: AudioService; // Optional. For sound and music playback.
  gameName?: string;        // Optional. Used for naming the game, e.g., in high score storage.
  enableHighScoreStorage?: boolean; // Default: false. If true, game will attempt to store/retrieve high scores.
  isBrowserEnvironment?: boolean; // Default: false. Must be true for high score storage to work (indicates localStorage availability).
}
```

## Frame-by-Frame Rendering Pattern

### Automatic Screen Clearing
BaseGame automatically clears the screen each frame before calling `updateGame()`. This simplifies development by eliminating manual position tracking.

### Critical: Draw Order and Collision Detection
When using screen-based collision detection with `getCellInfo()`, **static elements must be drawn before collision checks**:

```typescript
public updateGame(inputState: InputState): void {
  // 1. FIRST: Draw all static elements (walls, obstacles, items)
  this.drawStaticElements();
  
  // 2. THEN: Process movement with collision detection
  if (this.isPassable(newX, newY)) {
    this.playerX = newX;
    this.playerY = newY;
  }
  
  // 3. FINALLY: Draw dynamic elements (player, enemies)
  this.drawPlayer();
}
```

### Collision Detection Strategies

#### 1. Array-Based Detection (Recommended)
Store game state in arrays, independent of screen rendering:
```typescript
private obstacles: Array<{x: number, y: number}> = [];

private isPassable(x: number, y: number): boolean {
  return !this.obstacles.some(obs => obs.x === x && obs.y === y);
}
```

**Advantages:**
- Drawing order independent
- Better performance
- Clearer game logic
- Easier debugging

#### 2. Screen-Based Detection
Use `getCellInfo()` for collision detection:
```typescript
private isPassable(x: number, y: number): boolean {
  const cell = this.getCellInfo(x, y);
  return cell?.attributes.isPassable !== false;
}
```

**Important:** Static elements **must** be drawn before collision checks when using this method.

### Best Practices
- **Prefer array-based collision detection** for game logic
- Use screen-based detection only for visual effects or simple cases
- Always document your collision detection strategy
- Test collision edge cases thoroughly

## Development Workflow

### 1. Create Game Structure
```bash
mkdir src/games/yourGame
```

### 2. Implement Core Logic
Start with [core.ts](mdc:src/games/defaultGame/core.ts) as reference:
- Extend BaseGame with proper options interface
- Implement required abstract methods
- Use established patterns (see coding standards)

### 3. Set Up Testing
Create [sim.ts](mdc:src/games/defaultGame/sim.ts) for simulation testing:
- Use `npm run sim:yourGame` for rapid iteration

### 4. Browser Integration
Create [browser.ts](mdc:src/games/defaultGame/browser.ts):
```typescript
import { initStandardTextGame } from "../../utils/browserHelper.js";

const winCondition = (game: any) => {
  // Define your win condition logic here
  return game.isGameWon(); // Use BaseGame's built-in win state
};

initStandardTextGame(
  () => new YourGame(),
  winCondition
);
```

### 5. Add NPM Script
Add to [package.json](mdc:package.json):
```json
"sim:yourGame": "npx tsx src/games/yourGame/sim.ts"
```

## Testing Strategy
- **Primary**: Use simulation (`npm run sim:yourGame`) for rapid development
- **Secondary**: Browser testing with `npm run dev`


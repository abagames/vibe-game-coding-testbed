---
description: 
globs: ./**/*.ts
alwaysApply: false
---
# VGCT Coding Standards

## Type Definitions
Use types from [coreTypes.ts](mdc:src/core/coreTypes.ts):
- `InputState` for input handling
- `CellAttributes` for cell styling
- `CellInfo` for grid data
- `GridData` for the full screen
- `cglColor` for color values

## Performance Guidelines
- Optimize for 40×25 grid operations
- Minimize object creation in game loops
- Use array indexing for frequent lookups
- Cache frequently accessed values
- **Prefer array-based collision detection** over screen-based

## Code Organization
- Keep game logic in `core.ts`
- Separate simulation setup in `sim.ts`
- Minimal browser integration in `browser.ts`
- Follow [defaultGame example](mdc:src/games/defaultGame) structure

## Example Reference
See [defaultGame core.ts](mdc:src/games/defaultGame/core.ts) for examples of:
- Proper BaseGame inheritance with named arguments
- Array-based collision detection (`obstacles`, `items` arrays)
- Efficient direction handling with numeric constants
- Custom BaseGame method overriding (`loseLife()`)
- Proper game state management

## Commenting
- Focus on *Why* not *What* in comments. Explain the reasoning behind code choices, not just what the code does.

## Architectural Style
- Prefer functions over classes. Aim for a more functional programming style where appropriate, using classes sparingly and only when their benefits (e.g., clear state encapsulation, inheritance) are significant.

## Type Safety Guidelines

### ❌ Avoid Type Weakening Features
**Minimize use of type assertions and `any`** except for debugging purposes:

```typescript
// ✅ Correct - Use type guards
function isEnemy(obj: unknown): obj is Enemy {
  return typeof obj === 'object' && obj !== null && 'type' in obj;
}

if (isEnemy(entity)) {
  // TypeScript knows entity is Enemy here
  entity.moveCounter++;
}

// ✅ Correct - Use type predicates
const splitters = enemies.filter((enemy): enemy is SplitterEnemy => 
  enemy.type === EnemyType.SPLITTER
);

// ✅ Acceptable - String literal types with const assertion
const CONFIG = {
  color: "purple" as const,
  displayChar: "S"
};

// ❌ Avoid - Type assertions without proper guards
const enemy = getEntity() as Enemy; // Dangerous!

// ❌ Avoid - any type (except for debugging)
function processData(data: any) { // Loses all type safety
  return data.someProperty;
}

// ⚠️ Debug only - Temporary type escape for investigation
const debugData = unknownObject as any; // Only for debugging!
console.log('Debug:', debugData.someProperty);
```

### ✅ Preferred Type Safety Patterns
- Use discriminated unions with type guards
- Leverage TypeScript's control flow analysis
- Use type predicates for filtering
- Employ const assertions for literal types
- Define proper interfaces and types upfront

## Mandatory Patterns

### ❌ Avoid Enums
**NEVER use TypeScript enums**. Use numeric constants instead:
```typescript
// ✅ Correct
const INITIAL_LIVES = 3;
const PLAYER_MOVEMENT_INTERVAL = 3;

// ❌ Incorrect
enum GameConstants { INITIAL_LIVES = 3, MOVEMENT_INTERVAL = 3 }
```

### ✅ Use Named Arguments
For optional parameters, use interface-based options:
```typescript
// ✅ Correct
interface GameOptions {
  initialLives?: number;
  gameSpeed?: number;
  movementInterval?: number;
  obstacleCount?: number;
}
constructor(options: GameOptions = {}) {
  const { 
    initialLives = 3, 
    gameSpeed = 1.0,
    movementInterval = 3,
    obstacleCount = 20 
  } = options;
  super({ initialLives, gameSpeed });
}

// ❌ Incorrect
constructor(initialLives: number = 3, gameSpeed: number = 1.0, interval: number = 3) {}
```

## BaseGame Built-in Methods

All games extending BaseGame have access to these core methods:

### Drawing Methods
- `drawText(text, x, y, attributes?)`: Draw text to virtual screen
- `drawCenteredText(text, y, attributes?)`: Draw centered text at y coordinate

### Game State Methods
- `getCellInfo(x, y)`: Get cell information at coordinates
- `addScore(value)`: Modify score
- `loseLife()`: Decrease lives, handle game over
- `winGame()`: Mark game as won and trigger game over
- `getScore()`, `getLives()`, `isGameOver()`, `isGameWon()`: State getters
- `getVirtualScreenData()`: Get the full grid

### Speed Control Methods
- `setGameSpeed(speed)`: Set game speed (0.1-3.0 range)
- `getGameSpeed()`: Get current game speed
- `adjustGameSpeed(delta)`: Adjust speed by delta amount

### Automatic UI Methods
These methods are called automatically by BaseGame:
- `renderStandardUI()`: Renders restart instruction
- `renderGameOverScreen(wonGame?)`: Renders game over screen with restart prompt

## Browser Helper Functions

### Input Handling
- `mapCrispInputToGameInputState()`: Converts crisp-game-lib keyboard input to InputState
  - Maps Arrow keys + WASD → directional input
  - Maps Space/Enter/Z/X → action1

### Game Setup
- `initStandardTextGame(gameFactory, customOptions?)`: Complete game initialization
- `createStandardGameOptions()`: Creates standard crisp-game-lib options for 40×25 text games
- `createStandardGameLoop(gameFactory)`: Creates game loop with input handling

### Rendering
- `renderVirtualScreen(virtualScreenData, width, height, charWidth, charHeight)`: Draws the 40×25 grid to canvas






